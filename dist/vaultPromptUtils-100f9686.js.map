{"version":3,"file":"vaultPromptUtils-100f9686.js","sources":["../vaultPromptUtils.mjs"],"sourcesContent":["/**\n * Fetch all secret names and their tags from the Key Vault\n */\nexport async function getVaultSecretsWithTags(vaultUrl, credential) {\n  const client = new SecretClient(vaultUrl, credential);\n  const secrets = [];\n  for await (const secretProperties of client.listPropertiesOfSecrets()) {\n    secrets.push({ name: secretProperties.name, tags: secretProperties.tags || {} });\n  }\n  return secrets;\n}\n\n/**\n * Build groupings from secrets based on their 'group' tag\n */\nexport function buildGroupingsFromTags(secrets) {\n  const groupings = Object.create(null);\n  for (const secret of secrets) {\n    const group = secret.tags.group;\n    if (group) {\n      if (!Array.isArray(groupings[group])) groupings[group] = [];\n      groupings[group].push(secret.name);\n    }\n  }\n  return groupings;\n}\nimport { SecretClient } from '@azure/keyvault-secrets';\nimport inquirer from 'inquirer';\n\n/**\n * Fetch all secret names from the Key Vault\n */\nexport async function getVaultSecretNames(vaultUrl, credential) {\n  const client = new SecretClient(vaultUrl, credential);\n  const secretNames = [];\n  for await (const secretProperties of client.listPropertiesOfSecrets()) {\n    secretNames.push(secretProperties.name);\n  }\n  return secretNames;\n}\n\n/**\n * Prompt user for values for each secret in the vault\n */\nexport async function promptForVaultSecrets({ vaultUrl, credential }) {\n  const client = new SecretClient(vaultUrl, credential);\n  const secrets = await getVaultSecretsWithTags(vaultUrl, credential);\n  if (secrets.length === 0) {\n    console.log('No secrets found in Key Vault.');\n    return {};\n  }\n  const groupings = buildGroupingsFromTags(secrets);\n  let answers = {};\n  // Build dynamic queries for discovered secrets/groups\n  const { buildQueries, promptForValue } = await import('./promptUtils.mjs');\n  // Build a config-like object from Key Vault secrets (in-memory only, not exported)\n  const dynamicConfig = { PROPERTIES: {}, GROUPINGS: {} };\n  for (const [group, secretNames] of Object.entries(groupings)) {\n    let parsedSecrets = {};\n    let keySets = {};\n    for (const name of secretNames) {\n      try {\n        const secret = await client.getSecret(name);\n        const parsed = JSON.parse(secret.value);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          parsedSecrets[name] = parsed;\n          keySets[name] = Object.keys(parsed);\n        }\n      } catch {}\n    }\n    const keySetCounts = {};\n    const keySetMap = {};\n    for (const name of Object.keys(keySets)) {\n      const keys = keySets[name];\n      const keyStr = keys.sort().join('||');\n      keySetCounts[keyStr] = (keySetCounts[keyStr] || 0) + 1;\n      keySetMap[name] = keyStr;\n    }\n    let majorityKeyStr = null;\n    let maxCount = 0;\n    for (const [keyStr, count] of Object.entries(keySetCounts)) {\n      if (count > maxCount) {\n        maxCount = count;\n        majorityKeyStr = keyStr;\n      }\n    }\n    const majorityKeys = majorityKeyStr ? majorityKeyStr.split('||') : [];\n    const validGroupSecrets = Object.keys(keySetMap).filter(name => keySetMap[name] === majorityKeyStr);\n    if (validGroupSecrets.length > 0 && majorityKeys.length > 0) {\n      dynamicConfig.GROUPINGS[group] = {\n        KEYS: validGroupSecrets,\n        VALUES: majorityKeys,\n        PROMPT_MESSAGE: `Choose value for group '${group}' (applies to: ${validGroupSecrets.join(', ')})`\n      };\n      for (const name of validGroupSecrets) {\n        dynamicConfig.PROPERTIES[name] = majorityKeys;\n      }\n    }\n    // Eject secrets with different key sets\n    const invalidGroupSecrets = secretNames.filter(name => !validGroupSecrets.includes(name));\n    for (const name of invalidGroupSecrets) {\n      try {\n        const secret = await client.getSecret(name);\n        const parsed = JSON.parse(secret.value);\n        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n          dynamicConfig.PROPERTIES[name] = Object.keys(parsed);\n        } else {\n          dynamicConfig.PROPERTIES[name] = [];\n        }\n      } catch {\n        dynamicConfig.PROPERTIES[name] = [];\n      }\n    }\n  }\n  // Add ungrouped secrets (in-memory only)\n  const ungrouped = secrets.filter(s => !s.tags.group).map(s => s.name);\n  for (const name of ungrouped) {\n    try {\n      const secret = await client.getSecret(name);\n      const parsed = JSON.parse(secret.value);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        dynamicConfig.PROPERTIES[name] = Object.keys(parsed);\n      } else {\n        dynamicConfig.PROPERTIES[name] = [];\n      }\n    } catch {\n      dynamicConfig.PROPERTIES[name] = [];\n    }\n  }\n  // Use shared prompt logic\n  const queriesMap = buildQueries(dynamicConfig);\n  // answers already declared above\n  for (const item of Array.from(queriesMap.keys())) {\n    // Use custom prompt message for group items if present\n    let promptMessage;\n    if (item.startsWith('GROUP:')) {\n      const groupName = item.replace('GROUP:', '');\n      const groupObj = dynamicConfig.GROUPINGS[groupName];\n      if (groupObj && groupObj.PROMPT_MESSAGE) {\n        promptMessage = groupObj.PROMPT_MESSAGE;\n      }\n    }\n    const result = await promptForValue(item, queriesMap, {}, dynamicConfig, promptMessage);\n    Object.assign(answers, result);\n  }\n\n  // Now, for each answer, fetch the actual value from Key Vault if it's a JSON secret\n  let finalAnswers = {};\n  for (const [name, selected] of Object.entries(answers)) {\n    try {\n      const secret = await client.getSecret(name);\n      const secretValue = secret.value;\n      const parsed = JSON.parse(secretValue);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed) && selected in parsed) {\n        finalAnswers[name] = parsed[selected];\n      } else {\n        finalAnswers[name] = selected;\n      }\n    } catch {\n      finalAnswers[name] = selected;\n    }\n  }\n  return finalAnswers;\n}\n"],"names":["async","getVaultSecretsWithTags","vaultUrl","credential","client","SecretClient","secrets","secretProperties","listPropertiesOfSecrets","push","name","tags","buildGroupingsFromTags","groupings","Object","create","secret","group","Array","isArray","getVaultSecretNames","secretNames","promptForVaultSecrets","length","console","log","answers","buildQueries","promptForValue","import","then","n","b","dynamicConfig","PROPERTIES","GROUPINGS","entries","parsedSecrets","keySets","getSecret","parsed","JSON","parse","value","keys","keySetCounts","keySetMap","keyStr","sort","join","majorityKeyStr","maxCount","count","majorityKeys","split","validGroupSecrets","filter","KEYS","VALUES","PROMPT_MESSAGE","invalidGroupSecrets","includes","ungrouped","s","map","queriesMap","item","from","promptMessage","startsWith","groupName","replace","groupObj","result","assign","finalAnswers","selected","secretValue"],"mappings":"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"}